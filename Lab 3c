# Python Lab Assignment: Lists, Memory, Comprehensions, Sets, and Dictionaries

# Generate a list of 100 integers and verify type

my_list = list(range(1, 101))
print("Type of my_list:", type(my_list))
print("First 10 elements:", my_list[:10])

# Apply four list methods
my_list.append(101)          # Add an item to the end
my_list.insert(0, 0)         # Insert at the beginning
my_list.pop()                 # Remove the last item
my_list.reverse()             # Reverse the list
print("Modified list first 10 elements:", my_list[:10])

# Move last 3 items of a 10-item list to the beginning

example_list = list(range(1, 11))
example_list = example_list[-3:] + example_list[:-3]
print("Last 3 items moved to beginning:", example_list)

# Length of [[1,2]] * 3

length_list = len([[1, 2]] * 3)
print("Length of [[1,2]] * 3:", length_list)

# Memory addresses of list with duplicates

my_list_ten = [1, 2, 3, 2, 4, 5, 1, 6, 3, 7]
my_list_ten_mem = [id(item) for item in my_list_ten]
print("Memory addresses of my_list_ten items:", my_list_ten_mem)

# Identify unique and duplicate memory addresses
unique_mem = set(my_list_ten_mem)
duplicates_mem = [mem for mem in my_list_ten_mem if my_list_ten_mem.count(mem) > 1]
print("Unique memory addresses:", unique_mem)
print("Duplicate memory addresses:", duplicates_mem)

# Delete the list

del my_list_ten

# Create new list and compare memory addresses

my_new_list = [1, 2, 3, 2, 4, 5, 1, 6, 3, 7]
my_new_list_mem = [id(item) for item in my_new_list]
print("Memory addresses of new list:", my_new_list_mem)
print("Observation: Small integers may share memory addresses due to Python caching.")

# Copy nested list without affecting original

x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
import copy
y = copy.deepcopy(x)  # deep copy to avoid side-effects
y[0][0] = 100
print("Original x:", x)
print("Modified copy y:", y)

# Multiple expressions in list comprehension

numbers = [1, 2, 3]
result = [(n*2, n**2) for n in numbers]
print("Multiple expressions in list comprehension:", result)

# Count spaces using list comprehension

sentence = "To be, or not to be, this is the question"
space_count = sum([1 for char in sentence if char == " "])
print("Number of spaces in sentence:", space_count)

# Five list operations from Python Docs

fruits = ['apple', 'banana', 'cherry', 'date']
fruits.append('elderberry')
fruits.extend(['fig', 'grape'])
fruits.insert(2, 'blueberry')
fruits.remove('banana')
popped_item = fruits.pop()
print("Fruits after operations:", fruits)
print("Popped item:", popped_item)

# Using lists as stacks

stack = [1, 2, 3]
stack.append(4)
stack.append(5)
print("Stack before pop:", stack)
stack.pop()
print("Stack after pop:", stack)

# Using lists as queues with deque

from collections import deque
queue = deque(["Alice", "Bob", "Charlie"])
queue.append("Diana")
queue.append("Eve")
print("Queue before popleft:", queue)
queue.popleft()
print("Queue after popleft:", queue)

# Nested list comprehension and flattening

matrix = [[1,2,3], [4,5,6], [7,8,9]]
flattened = [num for row in matrix for num in row]
print("Flattened matrix:", flattened)

# Nested list comprehension to transpose
transposed = [[row[i] for row in matrix] for i in range(3)]
print("Transposed matrix:", transposed)

# 5. Set operations

basket = {'apple', 'orange', 'banana', 'apple'}
print("Unique fruits in basket:", basket)
a = set('abracadabra')
b = set('alacazam')
print("a - b:", a - b)
print("a | b:", a | b)
print("a & b:", a & b)
print("a ^ b:", a ^ b)

# Dictionary examples

tel = {'jack': 4098, 'sape': 4139}
tel['guido'] = 4127
del tel['sape']
print("Telephone directory:", tel)
for name, number in tel.items():
    print(name, number)

# Challenges
# I get confused about when to use append(), extend(), insert(), or pop(). It's hard to remember the differences
# I don't really understand why two variables with the same value might have different memeory addresses. It's tricky to visualize
# I struggle with knowing when to use a deep copy instead of a shallow copy, especially with nested lists
# I can mix up when to use a stack versus a queue.
